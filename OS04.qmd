---
title: "What's in a message?"
author: "Daniel Sjoberg and Ben Straub"
format: html
editor: source
---

```{r, echo = FALSE, message = FALSE}
library(tibble)
library(dplyr)
library(cli)
library(glue)
```

* Due on February 10th
* Presentation on Monday, March 17th at 1:30 in Oceans 11

## Introduction

Succinct and informative messaging to your users is important for any successful software project. 
These messages can help a user quickly self-diagnosis issues they are having with your software providing a more positive experience for the user.
The admiral R package, which seeks to help users of R to build ADaM datasets, is keen on this type of messaging. 
In this paper, we will walk you through several simple examples looking at how to improve messaging from R using base R and the cli and glue R packages. 
We will then look at admiral for additional examples where the team improved the messaing of the function using the cli package.
Finally, we will conclude with a brief collection of utlities that can aid you in your quest for improving messaging in R packages. 

## What's in a message?

Let's put yourself in a new user of R shoes. 
Perhaps you even are a new user and welcome! 
You type out the `mean` function and for some crazy reason decide to place `[1]` to access information you think should be available. 
R prints out the following message:

```{r, error = TRUE}
mean[1]
```
As a new user or even veteran user of R, this message is not very helpful.
What is a closure?
Could suggested advice to given to the user to help self-diagnosis? 
Will R even allow us to improve the language for warning and error messages?
Yes R does!

R produces many warning and error messages. 
Some are incredibly helpful from the start and others leave something to be deisred.
As you mature in your R career the more esoteric R messages become easier to understand and fix as your knowledge of the architecture grows.
If you develop custom code in a R package a great benefit to your users is that you, the developer, can produce even better messaging to help point your users in the right direction.
Help them not face a message like `object of type 'closure' is not subsettable` ever again!
In the next few sections, we have constructed a simple bmi function with dummy data that will showcase difficult to understand R messages and ways we can improve on those messages using base R and the glue and cli R packages. 
Let's get started!

```{r, error = TRUE}
hgt_good <- c(147, 163)
wgt_good <- c(54, 78.5)

bmi <- function(hgt, wgt) {
  wgt / (hgt / 100)^2
}

bmi(hgt = hgt_good, wgt = wgt_good)
```

Fantastic! Our bmi function is producing the correct results. Ready for production? No'mam! 

What if the user accidentally misstypes and inserts some character values into the variables?
Unfortunately, our bmi function quickly breaks down, which is good, but the message to the user is not very helpful, especially a user who might be new to R. How can we improve this messaging?


```{r, error = TRUE}
hgt_bad <- c("a", "b")
wgt_bad <- c("c", "d")

bmi(hgt = hgt_bad, wgt = wgt_bad)
```

The phrase "non-numeric argument to binary operator" doesn't really jump off the tongue and then there is a reference to `hgt/100`... where is that?

## Base R is here to help!

Let's add some checks on the inputs for our function and provide a simple message to user on what seems to be the problem.

```{r, error = TRUE}
# Check inputs using base R stop()
bmi <- function(hgt, wgt) {
  if (!is.numeric(hgt)) {
    stop("The hgt argument must be numeric.")
  }
  if (!is.numeric(wgt)) {
    stop("The wgt argument must be numeric.")
  }

  wgt / (hgt / 100)^2
}
bmi(hgt = hgt_good, wgt = wgt_good)
```
The bmi function is still producing the same results. 
Now let's try it with that pesky character data.

```{r, error = TRUE}
bmi(hgt = hgt_bad, wgt = wgt_bad)
```

Fabulous! Our updated function provides us with a better message around our contrived issue. 
But is all that information in the message helpful and does need it need to be all in red? 
Using the cli R package we can improve our messaging even more!

## cli R package is here to help!

The cli R package is a tool designed to help R developers create attractive and expressive command-line interfaces. It provides a suite of functions to enhance console output, making it more visually appealing and user-friendly. 
Key features of the cli package include:

* *Text Formatting*: It supports various styles, including color, bold, and underline, allowing developers to highlight important messages.
* *Progress Bars and Spinners*: These are included to indicate the progress of time-consuming tasks, improving user experience during long computations.
* *Boxes and Lists*: The package allows for the addition of borders and lists to format text in an organized way, making it easier to read and comprehend.
* *Unicode Symbols*: It supports a wide range of Unicode symbols, which can be used to add icons or symbols to command output.

Now we have some power with the cli package! 
We will make use of the `cli_abort()` function to create a custom error message that is more informative to the user. 

```{r, error = TRUE}
# check inputs using cli::cli_abort() ------------------------------------------
bmi <- function(hgt, wgt) {
  if (!is.numeric(hgt)) {
    cli::cli_abort("The hgt argument must be numeric.")
  }
  if (!is.numeric(wgt)) {
    cli::cli_abort("The wgt argument must be numeric.")
  }

  wgt / (hgt / 100)^2
}
bmi(hgt = hgt_good, wgt = wgt_good)
```
Looking fabulous! 
Now let's break it.

```{r, error =TRUE}
bmi(hgt = hgt_good, wgt = wgt_bad)
```
The message is much clearer to the user that the error is from the `bmi()` function.
Additionally, the cli packages provides a `rlang::last_trace()` link, so we can easily delve into the details if needed. 
But we can do even better if we make use of the glue R package!

## glue R package is here to help!

The glue package in R is designed to efficiently interpolate and paste together strings. Its primary abilities include:

* *String Interpolation*: glue allows you to embed R expressions inside curly braces {} within a string. The expressions are evaluated, and their results are interpolated into the string. This makes it highly convenient for dynamically generating strings with variable content.
* *Improved Readability*: The use of curly-brace syntax within strings can lead to cleaner and more readable code compared to traditional paste or sprintf functions, especially when dealing with a mixture of text and variable data.
* *Parameter Passing*: You can pass additional named arguments to the glue() function, which can be used within the string expressions. This feature is useful for keeping the code concise while providing custom evaluations.
* *Custom Separators*: The package allows specification of custom separators and collapse arguments, offering flexibility similar to paste() functions.
* *Integration with Tidyverse*: The syntax and design of glue make it a good fit for use alongside other tidyverse packages, enhancing its functionality in data manipulation and generation tasks.

We want the arguments causing issues to __pop out__ to the user. 
We can use the glue syntax `{.arg arg_name}` to achieve this as seen below.

```{r, error = TRUE}
# Use glue syntax to help make stuff pop!
bmi <- function(hgt, wgt) {
  if (!is.numeric(hgt)) {
    cli::cli_abort("The {.arg hgt} argument must be numeric.")
  }
  if (!is.numeric(wgt)) {
    cli::cli_abort("The {.arg wgt} argument must be numeric.")
  }

  wgt / (hgt / 100)^2
}

bmi(hgt = hgt_good, wgt = wgt_good)
```

Okay! Still working well so let's break it again.

```{r, error =TRUE}
bmi(hgt = hgt_good, wgt = wgt_bad)
```
We now have backticks surrounding the argument, which helps surface a possible malignant culprit.
Unfortunately, we are repeating ourselves inside our function with the two numeric checks. 
Let's add a `check_numeric()` function that makes use of `arg_name`.

```{r, error = TRUE}
# Adding a `check_numeric()` function ------------------------------------------
check_numeric <- function(x, arg_name = rlang::caller_arg(x)) {
  if (!is.numeric(x)) {
    cli::cli_abort("The {.arg {arg_name}} argument must be numeric.")
  }
  invisible(x)
}

bmi <- function(hgt, wgt) {
  check_numeric(hgt)
  check_numeric(wgt)

  wgt / (hgt / 100)^2
}
```

```{r}
bmi(hgt = hgt_good, wgt = wgt_good)
```
```{r, error = TRUE}
bmi(hgt = hgt_bad, wgt = wgt_bad)
```

Bah! We made our code less repetitive, but now our message to the user doesn't make a lot of sense as they might never see `check_numeric()`. 
We can use the available arguments in `cli_abort()` to specify the environment form which the user called the function, i.e. `call = parent.frame()`

# TODO: Daniel to add
>>>># - discuss `arg_name = rlang::caller_arg(x)` and what it does<<<<

```{r, error = TRUE}
# Add `check_numeric(call)` argument -------------------------------------------
check_numeric <- function(x, arg_name = rlang::caller_arg(x), call = parent.frame()) {
  if (!is.numeric(x)) {
    cli::cli_abort("The {.arg {arg_name}} argument must be numeric.", call = call)
  }
  invisible(x)
}

bmi <- function(hgt, wgt) {
  check_numeric(hgt)
  check_numeric(wgt)

  wgt / (hgt / 100)^2
}
bmi(hgt = hgt, wgt = wgt)
```

```{r, error = TRUE}
bmi(hgt = hgt_bad, wgt = wgt_bad)
```

Phew! We are back in action and are looking good! ...but we can keep going! 
How about we add a `check_positive()` function that checks that your data are all positive and add in a list of items using `x` for error and `i` for information to highlight key infomration to your users. 


```{r}
# Add `check_positive()` with `c("i"=)` -----------------------------------------
check_positive <- function(x, arg_name = rlang::caller_arg(x), call = parent.frame()) {
  if (any(x <= 0)) {
    cli::cli_abort(
      c(
        "x" = "All values in the vector passed in the {.arg {arg_name}} argument must be postive.",
        "i" = "Consider {.emph checking your data} before attempting to calculate BMI."
      ),
      call = call
    )
  }
  invisible(x)
}

bmi <- function(hgt, wgt) {
  check_numeric(hgt)
  check_numeric(wgt)
  check_positive(hgt)
  check_positive(wgt)

  wgt / (hgt / 100)^2
}
bmi(hgt = hgt_good, wgt = wgt_good)
```

```{r, error = TRUE}
bmi(hgt = hgt_good * -1, wgt = wgt_good)
```

The message is clear!  The function `bmi()` has an Error.  The argument hgt is receiving data that is not positive and we request that users double check that their data is correct.

## admiral Example

admiral has a helper package called admiraldev that utilises a lot of great functions from cli and glue packages.  In early 2024, we made an effort

```{r}
assert_s3_class <- function(arg, cls,
                            optional = FALSE,
                            arg_name = rlang::caller_arg(arg),
                            message = NULL,
                            call = parent.frame()) {
  # if argument is optional and the value is NULL, exit function
  if (is.null(arg) && optional) {
    return(invisible(arg))
  }

  # use default message if one not provided in the `message` argument
  message <-
    ifelse(
      is.null(message),
      "Argument {.arg {arg_name}} must be class {.cls {cls}}, but is {.obj_type_friendly {arg}}.",
      message
    )

  # print error if input does not match specified class
  if (!inherits(arg, cls)) {
    cli::cli_abort(message = messagge, call = call)
  }

  invisible(arg)
}
```


## Quality of Life Improvements

modern interface

snapshot testing

standalone scripts

## Helpful Links 

<https://github.com/ddsjoberg/ARD-onboarding> <https://www.danieldsjoberg.com/ARD-onboarding/05-cli-conditions.html> <https://github.com/r-lib/rlang/blob/main/R/standalone-types-check.R>
<https://glue.tidyverse.org/>
